Union:
unsorted: o(nlogn+mlogn),o(n+m)
    int doUnion(int a[], int n, int b[], int m)  {
        int res = 0;
        unordered_set<int>s;
        int min = (n<=m)?n:m;
        for(int i=0;i<min;i++){
            s.insert(a[i]);
            s.insert(b[i]);
        }
        for(int i=min;i<n;i++){
            s.insert(a[i]);
        }
        for(int i=min;i<m;i++){
            s.insert(b[i]);
        }
        return s.size();
    }

intersection:
unsorted:
create hashmap and if count of items is 2 
sorted: 
better: o(n*m),o(1)
#include <bits/stdc++.h> 
vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
{
	vector<int> ans;
 for(int i=0;i<n;i++){
	 for(int j=0;j<m;j++){
		 if(arr1[i]<arr2[j]){
	     break;
		 }
		 else if(arr1[i]==arr2[j]) {
			 ans.push_back(arr1[i]);
			 arr2[j]=INT_MIN;
			 break;
		 }
	 }
 }
	return ans;
}
best: o(min(n,m))
#include <bits/stdc++.h> 
vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
{
	vector<int> ans;
	int i=0,j=0;
	while(i<n&&j<m) {
		if(arr1[i]==arr2[j]) {
			ans.push_back(arr1[i]);
            i++;
			j++;
		}
		else if (arr1[i]<arr2[j]) {
			i++;
		} else {
			j++;
		}
	}
	return ans;
}
